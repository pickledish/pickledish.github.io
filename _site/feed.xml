<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Brandon Website</title>
    <description>Brandon Willett software developer guy! I like bicycles!</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 28 May 2018 23:13:13 -0400</pubDate>
    <lastBuildDate>Mon, 28 May 2018 23:13:13 -0400</lastBuildDate>
    <generator>Jekyll v3.7.0</generator>
    
      <item>
        <title>MC Time Series Subset Search</title>
        <description>&lt;h2 id=&quot;the-goal&quot;&gt;The Goal&lt;/h2&gt;

&lt;p&gt;The goal of the program is to take in a set of time-series data, in our current case stock closing prices for $n$ different stocks, and use a Monte Carlo analysis to determine the “best” subset of those $n$ stocks. In our case, “best” is defined to be the subset that yields a high return (during the analyzed time period of course, but hopefully holding for the future as well) while minimizing risk.&lt;/p&gt;

&lt;h2 id=&quot;what-we-currently-do&quot;&gt;What We Currently Do&lt;/h2&gt;

&lt;h3 id=&quot;the-setup&quot;&gt;The Setup&lt;/h3&gt;

&lt;p&gt;On the left of the screen, there are several input fields:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterations&lt;/code&gt;, which is an integer representing how thoroughly the algorithm investigates “best” subset possibilities&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Anneal&lt;/code&gt;, which is a real number used to determine how often “bad” states are accepted despite their “bad”-ness&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Risk Free&lt;/code&gt;, a real number in $[0,1]$ which adjusts the “return” vector to more accurately reflect real-life earnings&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Stock Codes&lt;/code&gt;, a comma-separated list of U.S. ticker names to fetch time-series price data of&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Start&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;End&lt;/code&gt;, the date range in which to fetch data for the aforementioned ticker names&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Sample&lt;/code&gt;, the frequency at which to sample the closing prices (every day, every month, every year, and so on)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Upon clicking “Submit”, we use the Quandl API to fetch up-to-date closing prices of the tickers based on &lt;code class=&quot;highlighter-rouge&quot;&gt;Stock Codes&lt;/code&gt; across the given date range &lt;code class=&quot;highlighter-rouge&quot;&gt;Start&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;End&lt;/code&gt;. Then, we arrange the data into a matrix $T$, with row-vectors being the data from a single stock, thus getting an $n \times m$ matrix where $m$ is the number of samples based on &lt;code class=&quot;highlighter-rouge&quot;&gt;Sample&lt;/code&gt;. From $T$, we create two new matrices:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;$C$, the correlation matrix, which is of dimension $n \times n$ and where entry $C_{ij}$ represents the correlation of the time-series row vectors of stock $i$ and stock $j$&lt;/li&gt;
  &lt;li&gt;$D$, a special matrix also of dimension $n \times n$, where $D$ is created using the covariance matrix through a process detailed below.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note: $C$ and $D$ are made deliberately so that they act in roughly the same way with respect to the algorithm, and either one can be dropped in to act as the driving matrix of the algorithm. We’ll just use $C$ below for simplicity.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Using our time-series matrix $T$, we also find $b$, the “average return” vector. Each of the $n$ components of $b$ is calculated as follows:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;b_i = n \cdot \left(\frac{T_{in}}{T_{i1}}\right)^{1\,/\,(n - 1)}&lt;/script&gt;

&lt;p&gt;Thus, equipped with an $n \times n$ matrix $C$ and a size-$n$ vector $b$, we can solve the equation $Cx = b$ to find the solution vector $x$, and then normalize $x$ to get $x’$. We then define the tuple $(C, x’, b)$ to be a “state” of our algorithm, and we can rephrase the Goal at the top as follows: we’re trying to find the state with the highest score, where the score of a state is defined to be:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;s(C, x', b) = \frac{
	\sum_{i=1}^n{b_i x_i'}
}{
	\sum_{i=1}^n{C_{ii}^2x_i'} + 
	\sum_{i=1}^n \sum_{j \neq i}{C_{ij} x_i' x_j'}
}&lt;/script&gt;

&lt;h3 id=&quot;finding-d&quot;&gt;Finding $D$&lt;/h3&gt;

&lt;p&gt;Using the correlation matrix $C$ gives good results, but is not an ideal solution, since the main diagonal of $C$ is all $1$, and thus it contains no information about a stock’s individual fluctuations (interpreted as risk). To combat this, we originally tried to use the covariance matrix $V$ of the time-series data instead, as in that case $V_{ii}$ the variance of an individual stock would be a factor. However, this yielded very poor results (for unclear reasons). Thus, we instead take the correlation matrix $C$ and modify its diagonal entries to obtain a suitable matrix $D$.&lt;/p&gt;

&lt;p&gt;First, we find $\beta$ as follows:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Hello&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Hello
How are you&lt;/li&gt;
      &lt;li&gt;Hello&lt;/li&gt;
      &lt;li&gt;Hello&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\beta = \max \left\{ \,\sum_{j = 1,\, j \neq i}^n{C_{ij}} \quad \text{ for all } i \in \{1,2,\ldots,n\} \right\}&lt;/script&gt;

&lt;p&gt;We calculate this value because we’d like $D$ to be positive definite, which is the case if and only if each entry on the diagonal is greater than the sum of all other values in its row. Therefore, $\beta$ is a “safe” scalar in that, if each entry on the diagonal of $C$ is at least $1$ and we multiply each of those entries by $\beta$, the result will necessarily be positive definite.&lt;/p&gt;

&lt;p&gt;Then, we can construct $D$. First, $D$ begins as a copy of $V$ the covariance matrix, except that each diagonal entry $D_{ii}$ is “normalized” (divided by the square of the mean of row $i$) and then “scaled” (divided by the minimum entry on the diagonal, so that the smallest diagonal entry is $1$ and all others are larger). Then, we copy into $D$ all of the non-main-diagonal entries from $C$ the correlation matrix, so that $D$ is &lt;em&gt;mostly&lt;/em&gt; the correlation matrix but with the main diagonal of $V$. Finally, we multiply the diagonal entries of $D$ by $\beta$, to ensure that $D$ is positive definite.&lt;/p&gt;

&lt;h3 id=&quot;the-algorithm&quot;&gt;The Algorithm&lt;/h3&gt;

&lt;p&gt;Now, this part would be simple if $n$ were always small, as we could just iterate over all possible subsets of tickers to find the one whose state gave the highest score. However, when $n$ is large, the fact that there are $2^n$ such subsets makes this solution intractable, so we’re forced to do a probabilistic search. The search goes as follows:&lt;/p&gt;

&lt;p&gt;For each integer $i$ from $1$ to $n$, we’ll randomly choose $i$ integers from $\{1,2,\ldots,n\}$ and “strike out” the rows and columns from $C$ corresponding to those integers to create $C’$ (as one would do in the process of cofactor expansion), and similarly the respective components of $b$ to create $b’$. Let the set of the indices of the remaining rows/columns in $C’$ be called $R$. We calculate the score of the state gotten from $C’$ and $b’$, and call that the “baseline”.&lt;/p&gt;

&lt;p&gt;Then, we repeat the process to get a new $C’$ and $b’$ based on a different set $R$ of remaining vertices, and if the score of that state is higher than the baseline, then it &lt;em&gt;becomes&lt;/em&gt; the new baseline. This process is repeated &lt;code class=&quot;highlighter-rouge&quot;&gt;Iterations&lt;/code&gt; times, and because we keep track of each $C’$, $b’$ and $R$, we can create histograms of which rows/columns are the most common to appear in “victorious” states (ones that beat the previous baseline and became the new baseline).&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note: Because this is an annealing algorithm, we also sometimes accept states whose scores are &lt;em&gt;lower&lt;/em&gt; than the baseline. The probability of this happening is given by whether $e^{ad} &amp;gt; \mu$, where $a$ is &lt;code class=&quot;highlighter-rouge&quot;&gt;Anneal&lt;/code&gt;, $d$ is the difference between the scores, and $\mu$ is uniformly random on $(0,1)$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Then to finish, once these histograms have been made (and the main loop of the algorithm is done), we find the best-guess optimum for each $i$ from $1$ to $n$, where this optimum is defined to be the tallest $i$ bars (the most common $i$ rows/columns in “victorious” states) in the specific histogram which corresponds to states where $|R| = i$. These best-guess optima are all sets of indices, each with a different size – the smallest one only has one element (presumably the index of the best stock) and the largest is $\{1,2,\ldots,n\}$. Then, for each such set $S$, we get the matrix $C’$ and vector $b’$ from $C$ and $b$ but with only indices from $S$ included, like before, and find the score of that state. The state that achieves the highest score in this process is the “best” subset of the $n$ stocks.&lt;/p&gt;

&lt;h3 id=&quot;comparisons&quot;&gt;Comparisons&lt;/h3&gt;

&lt;p&gt;At the end of the process, we have a “best” subset of rows to use according to the algorithm using matrix $C$. Then, we run the whole thing again, keeping all things the same except for using $D$ in place of $C$, and save that output’s “best” subset of rows as well. Then, at the bottom of the page’s rendered output, there’s a section labeled &lt;strong&gt;check the difference&lt;/strong&gt;. Here, one can enter a time period for data collection, and directly compare how the subset from $C$ and the subset from $D$ would perform in terms of returns over time.&lt;/p&gt;

&lt;p&gt;In addition, the area just above this (labeled &lt;strong&gt;compare portfolio performance&lt;/strong&gt;) allows for similar performance comparisons between the subset from $C$ and a uniform portfolio, the S&amp;amp;P 500, and a custom portfolio.&lt;/p&gt;

&lt;h2 id=&quot;areas-for-improvement&quot;&gt;Areas for Improvement&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Make the website “responsive”, so the interface is still usable on a smartphone or tablet&lt;/li&gt;
  &lt;li&gt;Very much of this process could be (and possibly needs to be) parallelized, though that would likely require a move away from Python as the implementation language&lt;/li&gt;
  &lt;li&gt;Figure out how hard it would be to add ETF functionality to the program, instead of only stocks&lt;/li&gt;
  &lt;li&gt;Similarly, we could add stocks from different countries&lt;/li&gt;
  &lt;li&gt;More (or different) graphs, maybe with JS, make the data easier to visualize&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 02 Feb 2016 00:00:00 -0500</pubDate>
        <link>http://localhost:4000/posts/mcwriteup/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/mcwriteup/</guid>
        
        
      </item>
    
      <item>
        <title>Higher Kinded Types Demystified</title>
        <description>&lt;p&gt;The concept of higher-kinded types is coming up more often these days, both because functional languages (where they’re more relevant) are on the rise in terms of popularity, and because it’s currently the source of a few hotly-debated issues, like whether Rust will ever “get” them. The concept in itself isn’t a complicated one, despite the name being off-putting (higher &lt;em&gt;kinded&lt;/em&gt;?), and understanding it is a great step in beginning to figure out some of the type-level programming that’s so popular in languages like Haskell and Scala. Abstraction city, here we come!&lt;/p&gt;

&lt;h2 id=&quot;first-functions&quot;&gt;First, Functions&lt;/h2&gt;

&lt;p&gt;It’s a bit easier to understand higher kinded types if we first talk about a very similar concept in a different universe, that might be more familiar: higher order functions. For those of us who are a few years out from an undergrad CS curriculum, a function is called “higher order” when it either takes in a function as a parameter or puts out a function as a return type. We can work our way up to higher order functions with a few examples:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Order 0&lt;/strong&gt; – &lt;code class=&quot;highlighter-rouge&quot;&gt;def seven(): Int = { return 7 }&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Order 1&lt;/strong&gt; – &lt;code class=&quot;highlighter-rouge&quot;&gt;def square(x: Int): Int = { return x * x }&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Order 2&lt;/strong&gt; – &lt;code class=&quot;highlighter-rouge&quot;&gt;def addSome(some: Int): Fun[Int -&amp;gt; Int] = { ... }&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Order 3&lt;/strong&gt; – &lt;code class=&quot;highlighter-rouge&quot;&gt;def operateSome(op: Operator): Fun[Int -&amp;gt; Fun[Int -&amp;gt; Int]] = { ... }&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We’ll go through each of these one by one. It’s clear that as the “order” of the function goes up, the function-nesting of its parameter type (or its return type) goes up too: at order 0, there are no parameters, so we end up with constant functions. And then, at order 1 the parameters are “normal” types, like &lt;code class=&quot;highlighter-rouge&quot;&gt;Int&lt;/code&gt;, but in a functional context they’re really constant functions themselves – after all, in &lt;code class=&quot;highlighter-rouge&quot;&gt;square&lt;/code&gt;, we can view &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; as a function that yields the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; every time it’s called.&lt;/p&gt;

&lt;p&gt;Then, at order 2, things get more interesting, and the return type is actually a non-constant function itself, which is a function that adds the value &lt;code class=&quot;highlighter-rouge&quot;&gt;some&lt;/code&gt; to an integer that’s passed into it. Thus, for example, we could write:&lt;/p&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addFour&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Fun&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addSome&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addFour&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// prints &quot;7&quot;, or so I hope
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now, it’s important to note that our &lt;strong&gt;Order 2&lt;/strong&gt; function here (&lt;code class=&quot;highlighter-rouge&quot;&gt;addSome&lt;/code&gt;) returns an &lt;strong&gt;Order 1&lt;/strong&gt; function, one that operates only on the constant types we talked about before. We could talk about a function that returns a function that returns a function (a second order function), of course – and we do, with the example of an order 3 function above! But that bumps us up another order, and after that point it starts getting convoluted. The takeaway here is that an order &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; function will take in or return a function of order &lt;script type=&quot;math/tex&quot;&gt;n-1&lt;/script&gt;, with our base case order 0 being a constant function.&lt;/p&gt;

&lt;h2 id=&quot;the-types-themselves&quot;&gt;The Types Themselves&lt;/h2&gt;

&lt;p&gt;So, it’s clear that the order of a function is based on how “nested” its parameter list is, and higher kinded types start to seem a bit less confusing when we realize the exact same thing is true for them.&lt;/p&gt;

&lt;h3 id=&quot;0th-order&quot;&gt;0th Order&lt;/h3&gt;

&lt;p&gt;Just like order-0 functions, these are our &lt;strong&gt;constant&lt;/strong&gt; types. They’re not parameterized on any other type, and are the most basic, everyday type we work with (and the first ones you’re introduced to when beginning a computer science curriculum). &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Int&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;Boolean&lt;/code&gt; all fit into this category, along with any structs or classes you’ve defined yourself in most cases – so, &lt;code class=&quot;highlighter-rouge&quot;&gt;Professor&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;ServiceOrder&lt;/code&gt; fit in here, too.&lt;/p&gt;

&lt;p&gt;Overall, one can think of a 0th order type as one that is able to “stand on its own”, without any help, which contrasts with higher-order types.&lt;/p&gt;

&lt;h3 id=&quot;1st-order&quot;&gt;1st Order&lt;/h3&gt;

&lt;p&gt;A first-order type is one that is &lt;em&gt;parameterized&lt;/em&gt; on a 0th order type, i.e. they take a type parameter just like how we saw a first-order function had a constant-function parameter (or return type). Thus, they’re not constant anymore because the type can change based on what type parameter it’s given, so they can’t be order-0 types anymore; we must have gone up an order.&lt;/p&gt;

&lt;p&gt;Just like constant types, these come up very often in conventional programming, with one of the most common examples being &lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt;. In most languages, &lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt; is homogeneous – each instance of &lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt; can hold one and only one type of object – and in fact &lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt; is parameterized on that type, which is why you’ll see &lt;code class=&quot;highlighter-rouge&quot;&gt;List&amp;lt;Int&amp;gt;&lt;/code&gt; in Java or &lt;code class=&quot;highlighter-rouge&quot;&gt;List String&lt;/code&gt; in Haskell. More examples of first-order types include &lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Option&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;Set&lt;/code&gt;, and we can write our own first-order classes using polymorphic constructs. It might be useful to think of these as “container types”, since in most cases they exist to “hold” instances of another type.&lt;/p&gt;

&lt;p&gt;So, we see that there are actually infinitely many ways to make a &lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt;, based on what’s passed in as its type parameter – just as there are infinitely many outputs of &lt;code class=&quot;highlighter-rouge&quot;&gt;square&lt;/code&gt; based on what integer is passed in as a value parameter.&lt;/p&gt;

&lt;h3 id=&quot;2nd-order&quot;&gt;2nd Order&lt;/h3&gt;

&lt;p&gt;So, these are the “scary ones”, the ones you’ll hear referred to as higher-kinded types (HKTs) along with third-order types and above. Just like first-order types (container types) allow us to abstract over base types (write code that works easily no matter what type we store inside a &lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt;), second-order types allow us to &lt;em&gt;abstract over containers&lt;/em&gt;. This is the key point to understand about HKTs, and also the point that makes for quite a hurdle – it’s a level of abstraction that we’re not used to thinking about. In effect, we’d like to be able to write code that will work on any kind of container type, whether it’s a &lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt;, an &lt;code class=&quot;highlighter-rouge&quot;&gt;Option&lt;/code&gt;, a &lt;code class=&quot;highlighter-rouge&quot;&gt;Set&lt;/code&gt;, or one of your own creation.&lt;/p&gt;

&lt;p&gt;So say, for example, that during the course of a Tuesday morning we find the need to write a function &lt;code class=&quot;highlighter-rouge&quot;&gt;merge&lt;/code&gt; that can take two &lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt;s and return a list that contains the elements that came from both. Then, we might write:&lt;/p&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;merge&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;further-reading&quot;&gt;Further Reading&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;The folks at Typelevel wrote a &lt;a href=&quot;https://typelevel.org/blog/2016/08/21/hkts-moving-forward.html&quot;&gt;similar article&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 02 Feb 2016 00:00:00 -0500</pubDate>
        <link>http://localhost:4000/posts/HKT/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/HKT/</guid>
        
        
      </item>
    
      <item>
        <title>Welcome to Jekyll!</title>
        <description>&lt;p&gt;You’ll find this post in your &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;To add new posts, simply add a file in the &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory that follows the convention &lt;code class=&quot;highlighter-rouge&quot;&gt;YYYY-MM-DD-name-of-post.ext&lt;/code&gt; and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Tom'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints 'Hi, Tome' to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href=&quot;http://jekyllrb.com&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://github.com/jekyll/jekyll-help&quot;&gt;Jekyll’s dedicated Help repository&lt;/a&gt;.&lt;/p&gt;

</description>
        <pubDate>Thu, 12 Feb 2015 08:46:40 -0500</pubDate>
        <link>http://localhost:4000/jekyll/update/2015/02/12/welcome-to-jekyll/</link>
        <guid isPermaLink="true">http://localhost:4000/jekyll/update/2015/02/12/welcome-to-jekyll/</guid>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
  </channel>
</rss>
