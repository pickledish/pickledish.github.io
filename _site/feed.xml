<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Brandon Website</title>
    <description>Brandon Willett software developer guy! I like bicycles!</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 21 Jul 2018 17:34:31 -0400</pubDate>
    <lastBuildDate>Sat, 21 Jul 2018 17:34:31 -0400</lastBuildDate>
    <generator>Jekyll v3.7.0</generator>
    
      <item>
        <title>Function Declaration Syntax, Compared</title>
        <description>&lt;p&gt;One part of a programming language that doesn’t get a lot of attention (in my opinion) is the syntax of a function declaration – how many parameters the function takes, what types they are, what it returns, and so on. It’s vitally important information (as I continue to pretend that dynamically-typed languages don’t exist), and it’s remarkable how each different programming language has an entirely unique way to represent it.&lt;/p&gt;

&lt;p&gt;Which of these ways is the most concise, to prevent going over an 80 or 100 character limit? More importantly, which one is the most readable? And do these two properties have to be inversely correlated?&lt;/p&gt;

&lt;p&gt;So, in order to compare them all, I’ve decided to write the declaration for a simple(ish) function in 5 different languages: C++, Java, Scala, Haskell, and OCaml. Let’s see how they stack up:&lt;/p&gt;

&lt;h3 id=&quot;scala&quot;&gt;Scala&lt;/h3&gt;

&lt;p&gt;The function we’ll be using is pretty simple: it takes two parameters, an array of objects belonging to an ordered set and an integer, and returns an array of something comparable (maybe it sorts the array, and then returns a smaller array of the biggest ones, based on the second parameter). Even though this “comparable” property has different names in different languages (&lt;code class=&quot;highlighter-rouge&quot;&gt;Comparable&lt;/code&gt; in Java, &lt;code class=&quot;highlighter-rouge&quot;&gt;Ord&lt;/code&gt; in Haskell, etc), but I’ll be using &lt;code class=&quot;highlighter-rouge&quot;&gt;Ord&lt;/code&gt; in each example anyway, for the sake of keeping the comparison just to syntactic overhead.&lt;/p&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;topn_sort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Ord&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;topn&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I feel like Scala is good to start with, because it provides a good baseline in all areas – not too long (64 characters), and easy enough to read, as the type of each parameter is noted right next to the name of the parameter, with the result type at the end. Interestingly, this short-and-sweet Scala function declaration is (like many things in Scala) syntactic sugar for a slightly uglier (but more true to Scala’s actual implementation of generic type constraints) syntax:&lt;/p&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;topn_sort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;topn&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;implicit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ev&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Ord&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So, here, we see a little bit of the nature of Scala’s generic type bounds, in that a kind of “typeclass object” is implicitly passed around to any function that would rely on the fact that &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; belongs to (or has an implementation for) &lt;code class=&quot;highlighter-rouge&quot;&gt;Ord&lt;/code&gt;. It’s significantly more verbose and (in my opinion) less readable, so it’s a good thing that the first syntax exists. However, it does bother me a bit that it’s effectively hiding the way that Scala is truly handling the constraint.&lt;/p&gt;

&lt;h3 id=&quot;java&quot;&gt;Java&lt;/h3&gt;

&lt;p&gt;Now, we’ll move on to Scala’s ancestor, which I had been expecting to be a bit worse:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ord&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;topn_sort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;topn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It definitely is longer than the Scala declaration, clocking in at 76 characters for the same amount of information. And, it seems a bit less readable, too – while the type is still right next to its parameter, it’s now in front of the parameter with only a space to separate them, and the return type comes at the front. While it may feel more familiar to developers who’ve worked a lot with C-style languages, it seems clear to me why most new languages are going the &lt;code class=&quot;highlighter-rouge&quot;&gt;param: Type&lt;/code&gt; route. Plus, &lt;code class=&quot;highlighter-rouge&quot;&gt;extends&lt;/code&gt; to show that &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; is ordered takes some familiarity with Java to understand.&lt;/p&gt;

&lt;p&gt;Return type is also just floating somewhere, which is hard to grok&lt;/p&gt;

&lt;h3 id=&quot;haskell&quot;&gt;Haskell&lt;/h3&gt;

&lt;p&gt;Flipping to the other end of the programming universe, we have the functional language Haskell:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;topn_sort&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Ord&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Array&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Array&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;topn_sort&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;topn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;74 total characters. Funny that Haskell functions + type signatures require repeating the name of the function, and yet in this case we still come in underneath the total character count for Java.&lt;/p&gt;

&lt;p&gt;Interesting right away is the fact that the function declaration spans two lines, which is quite uncommon even in languages today. I personally enjoy that it separates the type of the function from its implementation (the names of the parameters we use to show what the function does). However, it’s undoubtedly a ding against the style that the types are separated from the names of the parameters – if a Haskell function takes several parameters, you may have to drag a finger along the screen to match up its type on the top line.&lt;/p&gt;

&lt;p&gt;In addition, in typical Haskell style, there’s no keyword for the fact that &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; is in &lt;code class=&quot;highlighter-rouge&quot;&gt;Ord&lt;/code&gt;, just a little “implies” arrow before the type signature. Cute, and familiar to mathematicians, but that alone doesn’t make it any easier to grasp.&lt;/p&gt;

&lt;h3 id=&quot;ocaml&quot;&gt;OCaml&lt;/h3&gt;

</description>
        <pubDate>Mon, 16 Jul 2018 00:00:00 -0400</pubDate>
        <link>http://localhost:4000/posts/function-syntax/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/function-syntax/</guid>
        
        
      </item>
    
      <item>
        <title>Function Declaration Syntax, Compared</title>
        <description>&lt;p&gt;One part of a programming language that doesn’t get a lot of attention (in my opinion) is the syntax of a function declaration – how many parameters the function takes, what types they are, what it returns, and so on. It’s vitally important information (as I continue to pretend that dynamically-typed languages don’t exist), and it’s remarkable how each different programming language has an entirely unique way to represent it.&lt;/p&gt;

&lt;p&gt;Which of these ways is the most concise, to prevent going over an 80 or 100 character limit? More importantly, which one is the most readable? And do these two properties have to be inversely correlated?&lt;/p&gt;

&lt;p&gt;So, in order to compare them all, I’ve decided to write the declaration for a simple(ish) function in 5 different languages: C++, Java, Scala, Haskell, and OCaml. Let’s see how they stack up:&lt;/p&gt;

&lt;h3 id=&quot;scala&quot;&gt;Scala&lt;/h3&gt;

&lt;p&gt;The function we’ll be using is pretty simple: it takes two parameters, an array of objects belonging to an ordered set and an integer, and returns an array of something comparable (maybe it sorts the array, and then returns a smaller array of the biggest ones, based on the second parameter). Even though this “comparable” property has different names in different languages (&lt;code class=&quot;highlighter-rouge&quot;&gt;Comparable&lt;/code&gt; in Java, &lt;code class=&quot;highlighter-rouge&quot;&gt;Ord&lt;/code&gt; in Haskell, etc), but I’ll be using &lt;code class=&quot;highlighter-rouge&quot;&gt;Ord&lt;/code&gt; in each example anyway, for the sake of keeping the comparison just to syntactic overhead.&lt;/p&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;topn_sort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Ord&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;topn&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I feel like Scala is good to start with, because it provides a good baseline in all areas – not too long (64 characters), and easy enough to read, as the type of each parameter is noted right next to the name of the parameter, with the result type at the end. Interestingly, this short-and-sweet Scala function declaration is (like many things in Scala) syntactic sugar for a slightly uglier (but more true to Scala’s actual implementation of generic type constraints) syntax:&lt;/p&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;topn_sort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;topn&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;implicit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ev&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Ord&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So, here, we see a little bit of the nature of Scala’s generic type bounds, in that a kind of “typeclass object” is implicitly passed around to any function that would rely on the fact that &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; belongs to (or has an implementation for) &lt;code class=&quot;highlighter-rouge&quot;&gt;Ord&lt;/code&gt;. It’s significantly more verbose and (in my opinion) less readable, so it’s a good thing that the first syntax exists. However, it does bother me a bit that it’s effectively hiding the way that Scala is truly handling the constraint.&lt;/p&gt;

&lt;h3 id=&quot;java&quot;&gt;Java&lt;/h3&gt;

&lt;p&gt;Now, we’ll move on to Scala’s ancestor, which I had been expecting to be a bit worse:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ord&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;topn_sort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;topn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It definitely is longer than the Scala declaration, clocking in at 76 characters for the same amount of information. And, it seems a bit less readable, too – while the type is still right next to its parameter, it’s now in front of the parameter with only a space to separate them, and the return type comes at the front. While it may feel more familiar to developers who’ve worked a lot with C-style languages, it seems clear to me why most new languages are going the &lt;code class=&quot;highlighter-rouge&quot;&gt;param: Type&lt;/code&gt; route. Plus, &lt;code class=&quot;highlighter-rouge&quot;&gt;extends&lt;/code&gt; to show that &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; is ordered takes some familiarity with Java to understand.&lt;/p&gt;

&lt;p&gt;Return type of just floating, hard 2 grok&lt;/p&gt;

&lt;h3 id=&quot;haskell&quot;&gt;Haskell&lt;/h3&gt;

&lt;p&gt;Flipping to the other end of the programming universe, we have the functional language Haskell:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;topn_sort&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Ord&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Array&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Array&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;topn_sort&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;topn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;74 total characters. Funny that Haskell functions + type signatures require repeating the name of the function, and yet in this case we still come in underneath the total character count for Java.&lt;/p&gt;

&lt;p&gt;Interesting right away is the fact that the function declaration spans two lines, which is quite uncommon even in languages today. I personally enjoy that it separates the type of the function from its implementation (the names of the parameters we use to show what the function does). However, it’s undoubtedly a ding against the style that the types are separated from the names of the parameters – if a Haskell function takes several parameters, you may have to drag a finger along the screen to match up its type on the top line.&lt;/p&gt;

&lt;p&gt;In addition, in typical Haskell style, there’s no keyword for the fact that &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; is in &lt;code class=&quot;highlighter-rouge&quot;&gt;Ord&lt;/code&gt;, just a little “implies” arrow before the type signature. Cute, and familiar to mathematicians, but that alone doesn’t make it any easier to grasp.&lt;/p&gt;

&lt;h3 id=&quot;ocaml&quot;&gt;OCaml&lt;/h3&gt;

</description>
        <pubDate>Mon, 16 Jul 2018 00:00:00 -0400</pubDate>
        <link>http://localhost:4000/posts/function-syntax/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/function-syntax/</guid>
        
        
      </item>
    
      <item>
        <title>Is Abstraction Worth the Effort</title>
        <description>&lt;p&gt;I read a lot about abstraction. Both for work and for my own interests, I find it really interesting to see how people are taking challenging, complicated issues and attempting to make them understandable for the average Joe. Back in college, one of my professors would always say that “Computer Science is the science of abstraction”, and while I thought it was cute at the time, it’s only becoming more clear how correct the statement is: more often, it’s seeming to me like the whole developer world is just in a constant struggle to abstract without losing something important to the abyss.&lt;/p&gt;

&lt;p&gt;As developers, our entire world is built firmly upon a foundation of abstractions. We rely on them every day, on one level or another, to write code, communicate over the web, and find answers to our problems. And why not? The concept is amazing&lt;/p&gt;

&lt;p&gt;Truth be told, it’s not at all difficult to find examples of “bad abstractions”. The shining (or, very dull, I guess) example in this category would have to be the ORM, or Object-Relational Mapping, that has been criticized() many() times() on the Internet.&lt;/p&gt;

&lt;p&gt;But what &lt;em&gt;makes&lt;/em&gt; it bad?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The main point against abstractions you’ll hear is that they’re always “leaky”. What “leaky” means, in this instance, is that&lt;/li&gt;
  &lt;li&gt;Bad performance&lt;/li&gt;
  &lt;li&gt;This&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Some people believe that no abstraction can ever be “good enough”, these people are Go, Rustaceans or C evalgnesists
But look at compilers! We were able to abstract away &lt;em&gt;registers&lt;/em&gt; and &lt;em&gt;cycles&lt;/em&gt;!&lt;/p&gt;

&lt;p&gt;You just gotta find the balance&lt;/p&gt;
</description>
        <pubDate>Tue, 26 Jun 2018 00:00:00 -0400</pubDate>
        <link>http://localhost:4000/posts/abstraction/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/abstraction/</guid>
        
        
      </item>
    
      <item>
        <title>MC Time Series Subset Search</title>
        <description>&lt;h2 id=&quot;the-goal&quot;&gt;The Goal&lt;/h2&gt;

&lt;p&gt;The goal of the program is to take in a set of time-series data, in our current case stock closing prices for $n$ different stocks, and use a Monte Carlo analysis to determine the “best” subset of those $n$ stocks. In our case, “best” is defined to be the subset that yields a high return (during the analyzed time period of course, but hopefully holding for the future as well) while minimizing risk.&lt;/p&gt;

&lt;h2 id=&quot;what-we-currently-do&quot;&gt;What We Currently Do&lt;/h2&gt;

&lt;h3 id=&quot;the-setup&quot;&gt;The Setup&lt;/h3&gt;

&lt;p&gt;On the left of the screen, there are several input fields:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterations&lt;/code&gt;, which is an integer representing how thoroughly the algorithm investigates “best” subset possibilities&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Anneal&lt;/code&gt;, which is a real number used to determine how often “bad” states are accepted despite their “bad”-ness&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Risk Free&lt;/code&gt;, a real number in $[0,1]$ which adjusts the “return” vector to more accurately reflect real-life earnings&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Stock Codes&lt;/code&gt;, a comma-separated list of U.S. ticker names to fetch time-series price data of&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Start&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;End&lt;/code&gt;, the date range in which to fetch data for the aforementioned ticker names&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Sample&lt;/code&gt;, the frequency at which to sample the closing prices (every day, every month, every year, and so on)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Upon clicking “Submit”, we use the Quandl API to fetch up-to-date closing prices of the tickers based on &lt;code class=&quot;highlighter-rouge&quot;&gt;Stock Codes&lt;/code&gt; across the given date range &lt;code class=&quot;highlighter-rouge&quot;&gt;Start&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;End&lt;/code&gt;. Then, we arrange the data into a matrix $T$, with row-vectors being the data from a single stock, thus getting an $n \times m$ matrix where $m$ is the number of samples based on &lt;code class=&quot;highlighter-rouge&quot;&gt;Sample&lt;/code&gt;. From $T$, we create two new matrices:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;$C$, the correlation matrix, which is of dimension $n \times n$ and where entry $C_{ij}$ represents the correlation of the time-series row vectors of stock $i$ and stock $j$&lt;/li&gt;
  &lt;li&gt;$D$, a special matrix also of dimension $n \times n$, where $D$ is created using the covariance matrix through a process detailed below.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note: $C$ and $D$ are made deliberately so that they act in roughly the same way with respect to the algorithm, and either one can be dropped in to act as the driving matrix of the algorithm. We’ll just use $C$ below for simplicity.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Using our time-series matrix $T$, we also find $b$, the “average return” vector. Each of the $n$ components of $b$ is calculated as follows:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;b_i = n \cdot \left(\frac{T_{in}}{T_{i1}}\right)^{1\,/\,(n - 1)}&lt;/script&gt;

&lt;p&gt;Thus, equipped with an $n \times n$ matrix $C$ and a size-$n$ vector $b$, we can solve the equation $Cx = b$ to find the solution vector $x$, and then normalize $x$ to get $x’$. We then define the tuple $(C, x’, b)$ to be a “state” of our algorithm, and we can rephrase the Goal at the top as follows: we’re trying to find the state with the highest score, where the score of a state is defined to be:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;s(C, x', b) = \frac{
	\sum_{i=1}^n{b_i x_i'}
}{
	\sum_{i=1}^n{C_{ii}^2x_i'} + 
	\sum_{i=1}^n \sum_{j \neq i}{C_{ij} x_i' x_j'}
}&lt;/script&gt;

&lt;h3 id=&quot;finding-d&quot;&gt;Finding $D$&lt;/h3&gt;

&lt;p&gt;Using the correlation matrix $C$ gives good results, but is not an ideal solution, since the main diagonal of $C$ is all $1$, and thus it contains no information about a stock’s individual fluctuations (interpreted as risk). To combat this, we originally tried to use the covariance matrix $V$ of the time-series data instead, as in that case $V_{ii}$ the variance of an individual stock would be a factor. However, this yielded very poor results (for unclear reasons). Thus, we instead take the correlation matrix $C$ and modify its diagonal entries to obtain a suitable matrix $D$.&lt;/p&gt;

&lt;p&gt;First, we find $\beta$ as follows:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Hello&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Hello
How are you&lt;/li&gt;
      &lt;li&gt;Hello&lt;/li&gt;
      &lt;li&gt;Hello&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\beta = \max \left\{ \,\sum_{j = 1,\, j \neq i}^n{C_{ij}} \quad \text{ for all } i \in \{1,2,\ldots,n\} \right\}&lt;/script&gt;

&lt;p&gt;We calculate this value because we’d like $D$ to be positive definite, which is the case if and only if each entry on the diagonal is greater than the sum of all other values in its row. Therefore, $\beta$ is a “safe” scalar in that, if each entry on the diagonal of $C$ is at least $1$ and we multiply each of those entries by $\beta$, the result will necessarily be positive definite.&lt;/p&gt;

&lt;p&gt;Then, we can construct $D$. First, $D$ begins as a copy of $V$ the covariance matrix, except that each diagonal entry $D_{ii}$ is “normalized” (divided by the square of the mean of row $i$) and then “scaled” (divided by the minimum entry on the diagonal, so that the smallest diagonal entry is $1$ and all others are larger). Then, we copy into $D$ all of the non-main-diagonal entries from $C$ the correlation matrix, so that $D$ is &lt;em&gt;mostly&lt;/em&gt; the correlation matrix but with the main diagonal of $V$. Finally, we multiply the diagonal entries of $D$ by $\beta$, to ensure that $D$ is positive definite.&lt;/p&gt;

&lt;h3 id=&quot;the-algorithm&quot;&gt;The Algorithm&lt;/h3&gt;

&lt;p&gt;Now, this part would be simple if $n$ were always small, as we could just iterate over all possible subsets of tickers to find the one whose state gave the highest score. However, when $n$ is large, the fact that there are $2^n$ such subsets makes this solution intractable, so we’re forced to do a probabilistic search. The search goes as follows:&lt;/p&gt;

&lt;p&gt;For each integer $i$ from $1$ to $n$, we’ll randomly choose $i$ integers from $\{1,2,\ldots,n\}$ and “strike out” the rows and columns from $C$ corresponding to those integers to create $C’$ (as one would do in the process of cofactor expansion), and similarly the respective components of $b$ to create $b’$. Let the set of the indices of the remaining rows/columns in $C’$ be called $R$. We calculate the score of the state gotten from $C’$ and $b’$, and call that the “baseline”.&lt;/p&gt;

&lt;p&gt;Then, we repeat the process to get a new $C’$ and $b’$ based on a different set $R$ of remaining vertices, and if the score of that state is higher than the baseline, then it &lt;em&gt;becomes&lt;/em&gt; the new baseline. This process is repeated &lt;code class=&quot;highlighter-rouge&quot;&gt;Iterations&lt;/code&gt; times, and because we keep track of each $C’$, $b’$ and $R$, we can create histograms of which rows/columns are the most common to appear in “victorious” states (ones that beat the previous baseline and became the new baseline).&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note: Because this is an annealing algorithm, we also sometimes accept states whose scores are &lt;em&gt;lower&lt;/em&gt; than the baseline. The probability of this happening is given by whether $e^{ad} &amp;gt; \mu$, where $a$ is &lt;code class=&quot;highlighter-rouge&quot;&gt;Anneal&lt;/code&gt;, $d$ is the difference between the scores, and $\mu$ is uniformly random on $(0,1)$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Then to finish, once these histograms have been made (and the main loop of the algorithm is done), we find the best-guess optimum for each $i$ from $1$ to $n$, where this optimum is defined to be the tallest $i$ bars (the most common $i$ rows/columns in “victorious” states) in the specific histogram which corresponds to states where $|R| = i$. These best-guess optima are all sets of indices, each with a different size – the smallest one only has one element (presumably the index of the best stock) and the largest is $\{1,2,\ldots,n\}$. Then, for each such set $S$, we get the matrix $C’$ and vector $b’$ from $C$ and $b$ but with only indices from $S$ included, like before, and find the score of that state. The state that achieves the highest score in this process is the “best” subset of the $n$ stocks.&lt;/p&gt;

&lt;h3 id=&quot;comparisons&quot;&gt;Comparisons&lt;/h3&gt;

&lt;p&gt;At the end of the process, we have a “best” subset of rows to use according to the algorithm using matrix $C$. Then, we run the whole thing again, keeping all things the same except for using $D$ in place of $C$, and save that output’s “best” subset of rows as well. Then, at the bottom of the page’s rendered output, there’s a section labeled &lt;strong&gt;check the difference&lt;/strong&gt;. Here, one can enter a time period for data collection, and directly compare how the subset from $C$ and the subset from $D$ would perform in terms of returns over time.&lt;/p&gt;

&lt;p&gt;In addition, the area just above this (labeled &lt;strong&gt;compare portfolio performance&lt;/strong&gt;) allows for similar performance comparisons between the subset from $C$ and a uniform portfolio, the S&amp;amp;P 500, and a custom portfolio.&lt;/p&gt;

&lt;h2 id=&quot;areas-for-improvement&quot;&gt;Areas for Improvement&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Make the website “responsive”, so the interface is still usable on a smartphone or tablet&lt;/li&gt;
  &lt;li&gt;Very much of this process could be (and possibly needs to be) parallelized, though that would likely require a move away from Python as the implementation language&lt;/li&gt;
  &lt;li&gt;Figure out how hard it would be to add ETF functionality to the program, instead of only stocks&lt;/li&gt;
  &lt;li&gt;Similarly, we could add stocks from different countries&lt;/li&gt;
  &lt;li&gt;More (or different) graphs, maybe with JS, make the data easier to visualize&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 02 Feb 2018 00:00:00 -0500</pubDate>
        <link>http://localhost:4000/posts/mcwriteup/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/mcwriteup/</guid>
        
        
      </item>
    
      <item>
        <title>Higher Kinded Types Demystified</title>
        <description>&lt;p&gt;The concept of higher-kinded types is coming up more often these days, both because functional languages (where they’re more relevant) are on the rise in terms of popularity, and because it’s currently the source of a few hotly-debated issues, like whether Rust will ever “get” them. The concept in itself isn’t a complicated one, despite the name being off-putting (higher &lt;em&gt;kinded&lt;/em&gt;?), and understanding it is a great step in beginning to figure out some of the type-level programming that’s so popular in languages like Haskell and Scala. Abstraction city, here we come!&lt;/p&gt;

&lt;h2 id=&quot;first-functions&quot;&gt;First, Functions&lt;/h2&gt;

&lt;p&gt;It’s a bit easier to understand higher kinded types if we first talk about a very similar concept in a different universe, that might be more familiar: higher order functions. For those of us who are a few years out from an undergrad CS curriculum, a function is called “higher order” when it either takes in a function as a parameter or puts out a function as a return type. We can work our way up to higher order functions with a few examples:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Order 0&lt;/strong&gt; – &lt;code class=&quot;highlighter-rouge&quot;&gt;def seven(): Int = { return 7 }&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Order 1&lt;/strong&gt; – &lt;code class=&quot;highlighter-rouge&quot;&gt;def square(x: Int): Int = { return x * x }&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Order 2&lt;/strong&gt; – &lt;code class=&quot;highlighter-rouge&quot;&gt;def addSome(some: Int): Fun[Int -&amp;gt; Int] = { ... }&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Order 3&lt;/strong&gt; – &lt;code class=&quot;highlighter-rouge&quot;&gt;def operateSome(op: Operator): Fun[Int -&amp;gt; Fun[Int -&amp;gt; Int]] = { ... }&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We’ll go through each of these one by one. It’s clear that as the “order” of the function goes up, the function-nesting of its parameter type (or its return type) goes up too: at order 0, there are no parameters, so we end up with constant functions. And then, at order 1 the parameters are “normal” types, like &lt;code class=&quot;highlighter-rouge&quot;&gt;Int&lt;/code&gt;, but in a functional context they’re really constant functions themselves – after all, in &lt;code class=&quot;highlighter-rouge&quot;&gt;square&lt;/code&gt;, we can view &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; as a function that yields the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; every time it’s called.&lt;/p&gt;

&lt;p&gt;Then, at order 2, things get more interesting, and the return type is actually a non-constant function itself, which is a function that adds the value &lt;code class=&quot;highlighter-rouge&quot;&gt;some&lt;/code&gt; to an integer that’s passed into it. Thus, for example, we could write:&lt;/p&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addFour&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Fun&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addSome&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addFour&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// prints &quot;7&quot;, or so I hope
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now, it’s important to note that our &lt;strong&gt;Order 2&lt;/strong&gt; function here (&lt;code class=&quot;highlighter-rouge&quot;&gt;addSome&lt;/code&gt;) returns an &lt;strong&gt;Order 1&lt;/strong&gt; function, one that operates only on the constant types we talked about before. We could talk about a function that returns a function that returns a function (a second order function), of course – and we do, with the example of an order 3 function above! But that bumps us up another order, and after that point it starts getting convoluted. The takeaway here is that an order &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; function will take in or return a function of order &lt;script type=&quot;math/tex&quot;&gt;n-1&lt;/script&gt;, with our base case order 0 being a constant function.&lt;/p&gt;

&lt;h2 id=&quot;the-types-themselves&quot;&gt;The Types Themselves&lt;/h2&gt;

&lt;p&gt;So, it’s clear that the order of a function is based on how “nested” its parameter list is, and higher kinded types start to seem a bit less confusing when we realize the exact same thing is true for them.&lt;/p&gt;

&lt;h3 id=&quot;0th-order&quot;&gt;0th Order&lt;/h3&gt;

&lt;p&gt;Just like order-0 functions, these are our &lt;strong&gt;concrete&lt;/strong&gt; types. They’re not parameterized on any other type, and are the most basic, everyday type we work with (and the first ones you’re introduced to when beginning a computer science curriculum). &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Int&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;Boolean&lt;/code&gt; all fit into this category, along with any structs or classes you’ve defined yourself in most cases – so, &lt;code class=&quot;highlighter-rouge&quot;&gt;Professor&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;ServiceOrder&lt;/code&gt; fit in here, too.&lt;/p&gt;

&lt;p&gt;Overall, one can think of a 0th order type as one that is able to “stand on its own”, without any help, which contrasts with higher-order types.&lt;/p&gt;

&lt;h3 id=&quot;1st-order&quot;&gt;1st Order&lt;/h3&gt;

&lt;p&gt;A first-order type is one that is &lt;em&gt;parameterized&lt;/em&gt; on a 0th order type, i.e. they take a type parameter just like how we saw a first-order function had a constant-function parameter (or return type). Thus, they’re not constant anymore because the type can change based on what type parameter it’s given, so they can’t be order-0 types anymore; we must have gone up an order.&lt;/p&gt;

&lt;p&gt;Just like concrete types, these come up very often in conventional programming, with one of the most common examples being &lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt;. In most languages, &lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt; is homogeneous – each instance of &lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt; can hold one and only one type of object – and in fact &lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt; is parameterized on that type, which is why you’ll see &lt;code class=&quot;highlighter-rouge&quot;&gt;List&amp;lt;Int&amp;gt;&lt;/code&gt; in Java or &lt;code class=&quot;highlighter-rouge&quot;&gt;[Int]&lt;/code&gt; in Haskell. More examples of first-order types include &lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Option&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;Set&lt;/code&gt;, and we can write our own first-order classes using polymorphic constructs. It might be useful to think of these as “container types”, since in most cases they exist to “hold” instances of another type.&lt;/p&gt;

&lt;p&gt;So, we see that there are actually infinitely many ways to make a &lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt;, based on what’s passed in as its type parameter – just as there are infinitely many outputs of &lt;code class=&quot;highlighter-rouge&quot;&gt;square&lt;/code&gt; based on what integer is passed in as a value parameter.&lt;/p&gt;

&lt;h3 id=&quot;2nd-order&quot;&gt;2nd Order&lt;/h3&gt;

&lt;p&gt;So, these are the “scary ones”, the ones you’ll hear referred to as higher-kinded types (HKTs) along with third-order types and above. Just like first-order types (container types) allow us to abstract over base types (write code that works easily no matter what type we store inside a &lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt;), second-order types allow us to &lt;em&gt;abstract over containers&lt;/em&gt;. This is the key point to understand about HKTs, and also the point that makes for quite a hurdle – it’s a level of abstraction that we’re not used to thinking about. In effect, we’d like to be able to write code that will work on any kind of container type, whether it’s a &lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt;, an &lt;code class=&quot;highlighter-rouge&quot;&gt;Option&lt;/code&gt;, a &lt;code class=&quot;highlighter-rouge&quot;&gt;Set&lt;/code&gt;, or one of your own creation.&lt;/p&gt;

&lt;p&gt;So say, for example, that during the course of a Tuesday morning we find the need to write a function &lt;code class=&quot;highlighter-rouge&quot;&gt;merge&lt;/code&gt; that can take two &lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt;s and return a list that contains the elements that came from both. Then, we might write:&lt;/p&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;merge&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;further-reading&quot;&gt;Further Reading&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;The folks at Typelevel wrote a &lt;a href=&quot;https://typelevel.org/blog/2016/08/21/hkts-moving-forward.html&quot;&gt;similar article&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 18 Nov 2017 00:00:00 -0500</pubDate>
        <link>http://localhost:4000/posts/HKT/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/HKT/</guid>
        
        
      </item>
    
      <item>
        <title>Welcome to Jekyll!</title>
        <description>&lt;p&gt;You’ll find this post in your &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;To add new posts, simply add a file in the &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory that follows the convention &lt;code class=&quot;highlighter-rouge&quot;&gt;YYYY-MM-DD-name-of-post.ext&lt;/code&gt; and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Tom'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints 'Hi, Tome' to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href=&quot;http://jekyllrb.com&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://github.com/jekyll/jekyll-help&quot;&gt;Jekyll’s dedicated Help repository&lt;/a&gt;.&lt;/p&gt;

</description>
        <pubDate>Thu, 12 Feb 2015 08:46:40 -0500</pubDate>
        <link>http://localhost:4000/jekyll/update/2015/02/12/welcome-to-jekyll/</link>
        <guid isPermaLink="true">http://localhost:4000/jekyll/update/2015/02/12/welcome-to-jekyll/</guid>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
  </channel>
</rss>
